{"name":"D.js","tagline":"tiny promise/A+ implementation","body":"#D.js\r\nD.js is a tiny implementation of promises/A+ made for nodejs and client-side browser\r\n[![Build Status](https://travis-ci.org/malko/D.js.png?branch=master)](https://travis-ci.org/malko/D.js)\r\n\r\nIf you want to know more about promises/A+ you can visit this page: http://promises-aplus.github.io/promises-spec/\r\n<a href=\"http://promises-aplus.github.com/promises-spec\">\r\n    <img src=\"http://promises-aplus.github.com/promises-spec/assets/logo-small.png\"\r\n         alt=\"Promises/A+ logo\" title=\"Promises/A+ 1.0 compliant\" align=\"right\" />\r\n</a>\r\n\r\n## installation\r\n### nodejs\r\n```npm install d.js```\r\n### browsers\r\nclone the repository or just copy the files D.js or D.min.js to your server and then include it in your pages with a classic \r\n```<script src=\"D.js\"></script>```\r\nor using a javascript loader like [l.js](https://github.com/malko/l.js)\r\n\r\n## Making an async method that return a promise:\r\n\r\nexample in node js wrapping the fs.readFile function to work with promise\r\n```javascript\r\nvar fs = require('fs')\r\n\t, D = require('./D.js')\r\n;\r\n\r\n// define a method that will return a promise of a file read content\r\nfunction readPromise(filename){\r\n\tvar deferred = D();\r\n\tfs.readFile(filename, function (err, data) {\r\n  \t\tif( err ){\r\n\t\t\tdeferred.reject(err);\r\n\t\t} else {\r\n\t\t\tdeferred.resolve(data);\r\n\t\t}\r\n\t};\r\n\treturn deferred.promise;\r\n}\r\n// use our readPromise method we don't pass in a callback, we will pass it to the then method\r\nreadPromise('/etc/passwd')\r\n\t.then( // the then method return a promise as well so we can chain then calls\r\n\t\tfunction(data){ console.log(data); }\r\n\t\t,function(err){ console.log(err); }\r\n\t)\r\n;\r\n\r\n```\r\n\r\n\r\n## Addition to the Promises/A+ specs\r\nD.js offers a little more than the promises/A+ specification requirements here's the api:\r\n\r\n### Promises methods\r\nIn addition to the unique **then** method required by the specifications D.js add supports of the following to each promises:\r\n```javascript\r\npromise.isPending() // return false if the promise is fulfilled or rejected, true otherwise\r\npromise.getStatus() // return -1 if rejected, 0 is pending and 1 if fulfilled\r\npromise.success(onFulfilled); // same as promise.then(onFulfilled);\r\npromise.error(onRejected);   // same as promise.then(undefined,onRejected);\r\npromise.apply(onFulfilled,onRejected);\r\npromise.rethrow(onRejected) // helper for onR\tejected method that rethrow the reason of the rejection\r\npromise.rethrow() // see below for more info on rethrow behaviour\r\n \r\n\r\n```\r\n\r\nThe **apply** method is a minor variation of the **then** method but specifically useful for promises of Array. Instead of getting the promised Array passed as a single parameter to the onFulfilled callback it will apply it to the callback so each values of the promised array will become single parameters of the callback here a code example;\r\n\r\n```javascript\r\nvar arrayPromise = D.resolved([1,2,3]); // we'll talk about resolved later\r\narrayPromise.then(function(a){ /* a will contains the whole array */ })\r\narrayPromise.apply(function(a,b,c){ /* a will be 1, b is 2 and c is 3 */ }\r\n\r\n```\r\n\r\nThe **rethrow** method serves two different purposes\r\n - if received an onRejected method it will just ensure that onRejected rethrow the error this is just an helper here's an exemple of the same behaviour without using rethrow\r\n```javascript\r\nvar onRejectedResolve = function(reason){\r\n\tconsole.error(reason);\r\n\treturn 'resolvedvalue';\r\n}\r\n\r\n// first example the error is resolved\r\npromise\r\n\t.error(onRejectedResolve)\r\n\t.success(function(a){\r\n\t\t/* a now contains 'resolvedvalue' */\r\n\t})\r\n;\r\n\r\n// second example we want the same errorHandler but we don't want to resolve\r\npromise\r\n\t.error(function(reason){\r\n\t\tonRejectedResolve(reason);\r\n\t\tthrow reason;\r\n\t})\r\n\t.success(function(a){\r\n\t\t/* this success will never get called */\r\n\t})\r\n;\r\n\r\n// third example using the same errorHandler and rethrow. \r\n//This does exactly the same thing as second example \r\npromise\r\n\t.rethrow(onRejectedResolve)\r\n\t.success(function(a){\r\n\t\t/* this success will never get called */\r\n\t})\r\n;\r\n\r\n```\r\n - if no onRejected callback is given then it will behave differently. When you use a Promises/A+ library no Error is thrown outside of your promise library so it's sometimes difficult to debug. For this purpose you can use **rethrow** method that will really re-throw the error outside of the promise library. this is really useful for debugging but also to end your promise chain when you want an error to be effectively thrown.\r\n```javascript\r\npromise\r\n\t.success(function(){\r\n\t\tthrow \"there's no good reason\";\r\n\t})\r\n\t.error(function(reason){\r\n\t\tconsole.error(reason); \r\n\t\tthrow reason; \r\n\t\t/* \r\n\t\teven throwing again the reason won't make the reason visible outside the promise library\r\n\t\tthe error will go to the next error handler or simply be ignored if no error handler exists\r\n\t\t*/\r\n\t})\r\n\t// rethrow call WITHOUT ANY PARAMATER will rejectet the reason in the outside world and you will see an uncaught error\r\n\t.rethrow()\r\n;\r\n```\r\n\r\n## D properties and methods \r\n\r\n#### D() or D.defer()\r\nreturn a __deferred__ object with **promise** as a property and **resolve**, **fulfill** (alias of resolve), **reject** as methods\r\n#### D.alwaysAsync = true\r\nsetting this to false will broke the compliance to the Promises/A+ specification but will try to resolve promise immediatly if the value is available instead of forcing an async resolution this is not a recommended behaviour but it may be useful in some cases\r\n#### D.onlyFuncs = true\r\nThis setting passed to false will also break compliance with the Promises/A+ specification by allowing then, success, error, apply and rethrow to received values instead of callbacks for onFulfilled or onRejected and will resolve the promise with thoose values.\r\n#### D.resolved(value), D.fulfilled(value)\r\nreturn a resolved promise of __value__\r\n#### D.rejected(reason)\r\nreturn a rejected promise with given __reason__\r\n#### D.wait(time)\r\nreturn a promise that will resolve in __time__ ms\r\n#### D.delay(fn,delay)\r\nreturn a promise for the return value of __fn__ which will be resolved in __delay__ ms\r\n#### D.promisify(value)\r\ninternal method exposed that will return a resolved promised of value if value isn't a promise\r\n#### D.all(listOfPromise), D.all(promise0,promise1,promise....)\r\ntake a list of promise as single Array or as list or parameters and return a promise that will resolved only when all given promised are resolved. the promise will received given promises values as parameters\r\n#### D.nodeCapsule(fn), D.nodeCapsule(subject,fn)\r\nencapsulate typical node methods that wait for a callback(Err,param1,param2...) as last parameters and return the wrapped method which will return a promise of response usable with then, succes, ...\r\nie:\r\n```javascript\r\nvar fs = require('fs')\r\n\t, D = require('./D.js')\r\n\t, readFile = D.nodeStyle(fs,fs.readFile)\r\n;\r\n\r\nreadFile('/etc/passwd')\r\n\t.success(function(data){ console.log(data); })\r\n\t.rethrow()\r\n;\r\n\r\n```","google":"UA-38585409-3","note":"Don't delete this file! It's used internally to help with page regeneration."}