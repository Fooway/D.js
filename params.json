{"name":"D.js","tagline":"tiny promise/A+ implementation","body":"#D.js\r\nD.js is a tiny implementation of promises/A+ made for nodejs and client-side browser (tested in ie7+, firefox and chrome)\r\n[![Build Status](https://travis-ci.org/malko/D.js.png?branch=master)](https://travis-ci.org/malko/D.js)\r\n\r\nIf you want to know more about promises/A+ you can visit this page: http://promises-aplus.github.io/promises-spec/\r\n<a href=\"http://promises-aplus.github.com/promises-spec\">\r\n    <img src=\"http://promises-aplus.github.com/promises-spec/assets/logo-small.png\"\r\n         alt=\"Promises/A+ logo\" title=\"Promises/A+ 1.0 compliant\" align=\"right\" />\r\n</a>\r\n\r\n## installation\r\n### nodejs\r\n```npm install d.js```\r\n### browsers\r\nclone the repository or just copy the files D.js or D.min.js to your server and then include it in your pages with a classic\r\n```<script src=\"D.js\"></script>```\r\nor using a javascript loader like [l.js](https://github.com/malko/l.js)\r\n\r\n## Making an async method that return a promise:\r\n\r\nexample in node js wrapping the fs.readFile function to work with promise\r\n```javascript\r\nvar fs = require('fs')\r\n\t, D = require('d.js')\r\n;\r\n\r\n// define a method that will return a promise of a file read content\r\nfunction readPromise(filename){\r\n\tvar deferred = D();\r\n\tfs.readFile(filename, function (err, data) {\r\n  \t\tif( err ){\r\n\t\t\tdeferred.reject(err);\r\n\t\t} else {\r\n\t\t\tdeferred.resolve(data);\r\n\t\t}\r\n\t};\r\n\treturn deferred.promise;\r\n}\r\n// use our readPromise method we don't pass in a callback, we will pass it to the then method\r\nreadPromise('/etc/passwd')\r\n\t.then( // the then method return a promise as well so we can chain then calls\r\n\t\tfunction(data){ console.log(data); }\r\n\t\t,function(err){ console.log(err); }\r\n\t)\r\n;\r\n```\r\n## Addition to the Promises/A+ specs\r\nD.js offers a little more than the promises/A+ specification requirements. Here's the api:\r\n\r\n### Promises methods\r\nIn addition to the unique **then** method required by the specifications, D.js supports the following methods for each promise:\r\n```javascript\r\npromise.isPending() // return false if the promise is fulfilled or rejected, true otherwise\r\npromise.getStatus() // return -1 if rejected, 0 is pending and 1 if fulfilled\r\npromise.success(onFulfilled); // same as promise.then(onFulfilled);\r\npromise.error(onRejected);   // same as promise.then(undefined,onRejected);\r\npromise.otherwise(onRejected);   // alias of promise.error();\r\npromise.apply(onFulfilled,onRejected); // same as then but when received an array as promise resolution value will pass each array entry as single parameter of the onFulfill callback\r\npromise.spread(onFulfilled,onRejected); // alias of apply\r\npromise.ensure(onRejected);   // cleanup method which will be always executed regardless fulfillment or rejection\r\npromise.nodify(nodeStyleCallback); // take a single callback which wait for an error as first parameter. other resolution values are passed as with the apply/spread method\r\npromise.rethrow(onRejected) // helper for onRejected method that rethrow the reason of the rejection\r\npromise.rethrow() // see below for more info on rethrow behaviour\r\n```\r\n#### promise.apply / promise.spread:\r\nThe **apply** method is a minor variation of the **then** method especially useful for promises of Array. Instead of passing an Array as the first parameter of onFulfulled, it will pass each element of the Array as a different parameter. Here is an example:\r\n\r\n```javascript\r\nvar arrayPromise = D.resolved([1,2,3]); // we'll talk about resolved later\r\narrayPromise.then(function(a){ /* a will contains the whole array */ })\r\narrayPromise.apply(function(a,b,c){ /* a will be 1, b is 2 and c is 3 */ }\r\n```\r\n#### promise.ensure\r\nThe **ensure** method will return the same promise untouched. It is used for cleanup tasks and the given callback will be called regardless of the promise fulfillment or rejection.\r\nIt won't receive any parameter and the returned value won't serve to fulfill a new promise.\r\n#### promise.nodify\r\nThe **nodify** method is the counterpart of the **D.nodeCapsule** method. it take a single node style callback as parameter which wait for an Error as first parameter if any.\r\nIf the promise is fulfilled then the first parameter will be undefined and other promises values will be applied as with the **promise.apply** method.\r\nIf the promise is rejected then the first parameter will be the reason of the rejection and other parameters will be ommited.\r\n```javascript\r\npromise.nodify(function(err, arg1, arg2, arg3){\r\n\tif(err){\r\n\t\t// promise is rejected treat the error or rethrow it\r\n\t} else {\r\n\t\t// promise is fulfilled do some work with other arguments\r\n\t}\r\n});\r\n```\r\n#### promise.rethrow\r\nThe **rethrow** method serves two different purposes\r\n- When it receives an onRejected method, it will ensure that onRejected rethrows the error. Here's an exemple of the same behaviour without using rethrow\r\n\r\n```javascript\r\nvar onRejectedResolve = function(reason){\r\n\tconsole.error(reason);\r\n\treturn 'resolvedvalue';\r\n}\r\n\r\n// first example the error is resolved\r\npromise\r\n\t.error(onRejectedResolve)\r\n\t.success(function(a){\r\n\t\t/* a now contains 'resolvedvalue' */\r\n\t})\r\n;\r\n\r\n// second example we want the same errorHandler but we don't want to resolve\r\npromise\r\n\t.error(function(reason){\r\n\t\tonRejectedResolve(reason);\r\n\t\tthrow reason;\r\n\t})\r\n\t.success(function(a){\r\n\t\t/* this success will never get called */\r\n\t})\r\n;\r\n\r\n// third example using the same errorHandler and rethrow.\r\n// This does exactly the same thing as second example\r\npromise\r\n\t.rethrow(onRejectedResolve)\r\n\t.success(function(a){\r\n\t\t/* this success will never get called */\r\n\t})\r\n;\r\n```\r\n- If no onRejected callback is given, it will behave differently. When you use a Promises/A+ library no Error is thrown outside of your promise library so it's sometimes difficult to debug. For this purpose you can use the **rethrow** method that will really re-throw the error outside of the promise library. this is really useful for debugging but also to end your promise chain when you want an error to be effectively thrown.\r\n\r\n```javascript\r\npromise\r\n\t.success(function(){\r\n\t\tthrow \"there's no good reason\";\r\n\t})\r\n\t.error(function(reason){\r\n\t\tconsole.error(reason);\r\n\t\tthrow reason;\r\n\t\t/*\r\n\t\teven throwing again the reason won't make the reason visible outside the promise library\r\n\t\tthe error will go to the next error handler or simply be ignored if no error handler exists\r\n\t\t*/\r\n\t})\r\n\t// rethrow call WITHOUT ANY PARAMATER will rejectet the reason in the outside world and you will see an uncaught error\r\n\t.rethrow()\r\n;\r\n```\r\n\r\n## D properties and methods\r\n\r\n#### D() or D.defer()\r\nreturn a __deferred__ object with **promise** as a property and **resolve**, **fulfill** (alias of resolve), **reject** as methods\r\n#### D.alwaysAsync = true\r\nsetting this to false will broke the compliance to the Promises/A+ specification but will try to resolve promise immediatly if the value is available instead of forcing an async resolution this is not a recommended behaviour but it may be useful in some cases\r\n#### D.onlyFuncs = true\r\nThis setting passed to false will also break compliance with the Promises/A+ specification by allowing then, success, error, apply and rethrow to received values instead of callbacks for onFulfilled or onRejected and will resolve the promise with thoose values.\r\n#### D.resolved(value), D.fulfilled(value)\r\nreturn a resolved promise of __value__\r\n#### D.rejected(reason)\r\nreturn a rejected promise with given __reason__\r\n#### D.wait(time)\r\nreturn a promise that will resolve in __time__ ms\r\n#### D.delay(fn,delay)\r\nreturn a promise for the return value of __fn__ which will be resolved in __delay__ ms (if fn is not a function it will be used as the resolved value)\r\n#### D.promisify(value)\r\ninternal method exposed that will return a resolved promised of value if value isn't a promise\r\n#### D.all(listOfPromise), D.all(promise0,promise1,promise....)\r\ntake a list of promise as single Array or as list or parameters and return a promise that will resolved only when all given promised are resolved. the promise will received given promises values as parameters\r\n#### D.resolveAll(listOfPromise), D.resolveAll(promise0,promise1,promise....)\r\ntake a list of promise as single Array or as list or parameters and return an always fulfilled promise of array<promise> list of promises/values regardless of their fulfilled or rejected resolution.\r\n#### D.sequence(listOfFunction), D.sequence(fn0,fn1,fn....)\r\ntake a list of function to execute in order passing results of one to the other and return a promised of the last returned value. will be rejected if any of the function throw an error. as a convenience, it can also receive promises or direct values instead of functions in which case they will be considered as returned value\r\n#### D.nodeCapsule(fn), D.nodeCapsule(subject,fn)\r\nencapsulate typical node methods that wait for a callback(Err,param1,param2...) as last parameters and return the wrapped method which will return a promise of response usable with then, succes, ...\r\nie:\r\n```javascript\r\nvar fs = require('fs')\r\n\t, D = require('d.js')\r\n\t, readFile = D.nodeCapsule(fs,fs.readFile)\r\n;\r\n\r\nreadFile('/etc/passwd')\r\n\t.success(function(data){ console.log(data); })\r\n\t.rethrow()\r\n;\r\n```\r\n","google":"UA-38585409-3","note":"Don't delete this file! It's used internally to help with page regeneration."}